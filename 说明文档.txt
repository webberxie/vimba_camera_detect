
----------------------------------
说明文档：
用途：介绍基于vimba相机开发，并运用示例代码进行靶标检测，距离测算，以及各参数结果可视化；
创建时间：2020.10.14
初始编辑：助教谢雨含
实验课程：智能光电感知实验
----------------------------------

1、安装相机自带vimba viewer软件
----------------------------------------------------------

（1）打开Vimba_v4.0_Windows.exe，安装vimba4.0/4.2；勾选安装features：python系列开发包；
（建议全选即可）安装完成后，勾选安装驱动；安装完成后，桌面出现三个vimba系列图标。


（2）打开Vimba Viewer：连接相机USB到电脑端口；勾选vimba viewer的USB下的相机，即可自动
打开相机监测界面；点击左上方的运行按钮，即可运行相机；
界面上方有直方图功能；图像缩放功能；旋转功能等；
界面右侧有曝光时间(Exposure)，增益(Gain)，Gamma(伽马变换，调节暗亮)等；
可自行尝试调节以理解相机的基本参数，以及图像处理的基本原理。



2、进行vimbapython二次开发包的安装
------------------------------------------------------------

（1）安装python（可以直接安装在base环境，也可以基于annconda安装于虚拟环境）

（2）在vimba安装地址下找到vimbapython/source/开发包地址（注意该地址下会有一个setup.py文件）
打开cmd，进入vimba4.0/vimbapython/source/地址下；具体命令行操作：
d:              # 如果安装在D盘
cd vimba_4.0/vimbapython/source/

# 如果用的是虚拟环境的python，则先激活虚拟环境（否则不需要）；这里假设你的虚拟环境名为：mypython
activate mypython

# 安装自带的二次开发包
pip install .

# 安装我们所需要的numpy，opencv库
pip install numpy
pip install opencv


3、运行我们的实时运算代码，以及可视化界面代码；学习如何实现靶标的检测，以及距离测算
------------------------------------------------------------------

（1）将ui3.py，test.py，process.py放置到vimba_4.0/vimbapython/source/目录下；
下面是这三个代码的基本说明（更多详细信息见代码注释）：
ui3.py：基于qtdesigner建立的窗口界面并转换为代码，会被process.py所复用
test.py：对每一帧的图像进行实时靶标检测，并进行距离测算；需要提前标定相机焦距，以及靶标直径；
process.py：复用ui3.py界面，调用test.py中的检测函数进行检测，并对相机的基本参数进行可视化。

（2）运行：
保持相机与电脑的连接；（注意：python代码运行与vimba viewer只有一者可以在运行，不可同时占用相机）
运行test.py，进行实时检测；
运行process.py，进行实时监测与ui界面可视化；


4、基本算法原理：
-------------------------------------------------------------------
（1）靶标检测：
运用opencv的检测圆函数进行检测，获得检测到的多个圆形；
筛选出圆形内像素灰度值之和最低的圆形（说明黑色区域占比大，则检测圆与实际靶标更加贴合）
（示例代码没有做该操作，仅仅筛选出了半径最大的圆，待优化）

opencv检测圆函数内置实际包括多个步骤：
第一阶段：检测圆心

1.1、对输入图像边缘检测；
1.2、计算图形的梯度，并确定圆周线，其中圆周的梯度就是它的法线；
1.3、在二维霍夫空间内，绘出所有图形的梯度直线，某坐标点上累加和的值越大，说明在该点上直线相交的次数越多，也就是越有可能是圆心；
1.4、在霍夫空间的4邻域内进行非最大值抑制；
1.5、设定一个阈值，霍夫空间内累加和大于该阈值的点就对应于圆心。

第二阶段：检测圆半径
2.1、计算某一个圆心到所有圆周线的距离，这些距离中就有该圆心所对应的圆的半径的值，这些半径值当然是相等的，并且这些圆半径的数量要远远大于其他距离值相等的数量；
2.2、设定两个阈值，定义为最大半径和最小半径，保留距离在这两个半径之间的值，这意味着我们检测的圆不能太大，也不能太小；
2.3、对保留下来的距离进行排序；
2.4、找到距离相同的那些值，并计算相同值的数量；
2.5、设定一个阈值，只有相同值的数量大于该阈值，才认为该值是该圆心对应的圆半径；
2.6、对每一个圆心，完成上面的2.1～2.5步骤，得到所有的圆半径。

更多细节，以及函数各输入参数含义（影响检测到的圆的数量），可自行了解。


（2）距离测算
运用相似三角形原理：

# 初始焦距标定实验
 F = (P * D) / W
其中F为焦距，P为靶标在图像中所占据的像素个数，D为靶标与相机的距离，W为靶标实际宽度（直径）；
在初始标定测试中，相机拍摄靶标距离0.38m，靶标直径0.1m,在拍摄照片中直径占据像素长度为1028像素;
可计算得到焦距:F=1028*0.38/0.1;后续微调焦距，可视为微小误差；故我们视焦距为一定值

# 实际检测
预知靶标宽度为W0，根据检测算法得到靶标在图像中占据的像素点个数为P0，则：
D0= F0*W0/P0
即可得到实际检测中，靶标与相机的距离

# 更多思考：
1、靶标检测可否用深度学习的目标检测来做？推荐yolo系列算法（轻量，速度快）/SSD算法，有能力者可以自行尝试实现
2、靶标检测可否自行用其他传统图像处理方法实现？二值化，梯度边缘检测？与opencv内置函数对比效果如何？
3、靶标如果换成其他形状，如何检测？三角形？矩形？
4、距离测算依赖于标定实验，以及提前预知靶标尺寸，是否有更好的方法？单目深度估计是否可实现？精度是否能达到
工业要求？



